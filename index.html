<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Pattern Color Picker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            min-height: 100vh;
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 1200px;
            margin: 20px auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }


        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .control-group {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            gap: 20px;
            flex-wrap: wrap;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            font-weight: 600;
            color: #495057;
            min-width: 120px;
        }


        .color-value {
            font-family: 'Courier New', monospace;
            background: white;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            min-width: 80px;
            text-align: center;
            font-size: 0.9rem;
        }

        .preset-colors {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 8px;
            max-width: 100%;
        }
        
        .color-sections {
            display: flex;
            gap: 30px;
            justify-content: stretch;
            flex-wrap: wrap;
        }
        
        .color-section {
            flex: 1;
            min-width: 300px;
            max-width: none;
        }
        
        .pattern-color-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex: 1;
            min-width: 300px;
            max-width: none;
        }
        
        .pattern-selector {
            padding: 20px;
            text-align: center;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        .pattern-thumbnails {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .pattern-thumb {
            cursor: pointer;
            padding: 10px;
            border: 2px solid #444;
            border-radius: 8px;
            background: #2a2a2a;
            transition: all 0.3s ease;
            text-align: center;
            display: inline-block;
            width: auto;
            min-width: 140px;
            box-sizing: border-box;
        }
        
        .pattern-thumb:hover {
            border-color: #666;
            background: #333;
        }
        
        .pattern-thumb.active {
            border-color: #4ecdc4;
            background: #333;
        }
        
        .thumbnail-preview {
            width: 120px;
            height: 80px;
            background: #000;
            border: 1px solid #555;
            border-radius: 4px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .pattern-name {
            color: #ffffff;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .preset-color {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .preset-color:hover {
            transform: scale(1.1);
            border-color: #667eea;
        }

        .preset-color.active {
            border-color: #667eea;
            transform: scale(1.1);
        }

        .sticky-pattern-container {
            position: sticky;
            top: 0;
            z-index: 100;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .svg-container {
            padding: 0;
            text-align: center;
            background: white;
            border-bottom: 1px solid #e9ecef;
        }

        .color-info {
            padding: 15px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 15px;
            min-width: 300px;
        }

        .color-info-item {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
            justify-content: center;
        }


        .color-info-swatch {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            border: 2px solid #dee2e6;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .color-label {
            font-size: 0.9rem;
            color: #b0b0b0;
            font-weight: 500;
        }

        .color-name {
            font-size: 1.1rem;
            color: #ffffff;
            font-weight: 600;
            text-align: center;
        }

        .svg-wrapper {
            display: block;
            width: 100%;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .svg-wrapper:hover {
            transform: scale(1.02);
        }

        .svg-pattern {
            width: 100%;
            height: auto;
            display: block;
        }


        .download-btn {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        .slack-btn {
            background: linear-gradient(135deg, #4a154b 0%, #611f69 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(74, 21, 75, 0.3);
            font-size: 0.9rem;
            white-space: nowrap;
            margin-left: 10px;
        }

        .slack-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 21, 75, 0.4);
        }



        .clear-glaze-btn {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            color: #333;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(255, 154, 158, 0.3);
            margin-bottom: 15px;
            width: 100%;
        }

        .clear-glaze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 154, 158, 0.4);
        }

        .clear-glaze-btn.active {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .clear-glaze-btn.active:hover {
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        @media (max-width: 1200px) {
            .pattern-selector {
                flex-direction: column;
                gap: 20px;
            }
            
            .color-sections {
                flex-direction: column;
                gap: 20px;
            }
            
            .pattern-color-container {
                min-width: 100%;
                max-width: 100%;
            }
        }
        
        @media (max-width: 768px) {
            .pattern-selector {
                flex-direction: column;
                gap: 15px;
            }
            
            .color-info {
                gap: 15px;
                padding: 15px;
                min-width: auto;
            }
            
            .color-info-item {
                flex-direction: column;
                gap: 5px;
            }
            
            
            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .color-sections {
                flex-direction: column;
                gap: 20px;
            }
            
            .preset-colors {
                grid-template-columns: repeat(8, 1fr);
                max-width: 100%;
                gap: 6px;
            }
            
            .preset-color {
                width: 35px;
                height: 35px;
            }
        }
        
        @media (max-width: 480px) {
            .color-info-item {
                flex-direction: column;
                gap: 3px;
            }
            
            .color-info-swatch {
                width: 25px;
                height: 25px;
            }
            
            .preset-colors {
                grid-template-columns: repeat(6, 1fr);
            }
            
            .preset-color {
                width: 30px;
                height: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="pattern-selector">
            <div class="pattern-thumbnails">
                <div class="pattern-thumb" data-pattern="metaAndLines.svg">
                    <div class="thumbnail-preview" id="metaAndLinesThumb"></div>
                    <span class="pattern-name">Meta & Lines</span>
                </div>
                <div class="pattern-thumb" data-pattern="metaOriginal.svg">
                    <div class="thumbnail-preview" id="metaOriginalThumb"></div>
                    <span class="pattern-name">Meta Original</span>
                </div>
                <div class="pattern-thumb" data-pattern="truchet.svg">
                    <div class="thumbnail-preview" id="truchetThumb"></div>
                    <span class="pattern-name">Truchet</span>
                </div>
                <div class="pattern-thumb" data-pattern="loopyLines.svg">
                    <div class="thumbnail-preview" id="loopyLinesThumb"></div>
                    <span class="pattern-name">Loopy Lines</span>
                </div>
            </div>
            <div class="color-info">
                <div class="color-info-item">
                    <div class="color-info-swatch" id="bgColorSwatch"></div>
                    <span class="color-name" id="bgColorName">Select an underglaze color</span>
                </div>
                <div class="color-info-item">
                    <div class="color-info-swatch" id="patternColorSwatch"></div>
                    <span class="color-name" id="patternColorName">Select a glaze color</span>
                </div>
                <div class="color-info-item">
                    <button class="download-btn" onclick="downloadSVG()">Download</button>
                    <button class="slack-btn" onclick="sendToSlack()">Send to Slack</button>
                </div>
            </div>
        </div>
        
        <div class="sticky-pattern-container">
            <div class="svg-container">
                <div class="svg-wrapper">
                    <object id="svgObject" data="patterns/metaAndLines.svg" type="image/svg+xml" class="svg-pattern">
                        Your browser does not support SVG
                    </object>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="color-sections" id="presetColors">
                <!-- Color sections will be added by JavaScript -->
            </div>
            
        </div>
    </div>

    <script>
        let colorsData = null;
        let underglazeColors = [];
        let glazeColors = [];
        let currentBgColor = '#ffffff';
        let currentPatternColor = '#000000';
        let currentBgColorName = 'Select an underglaze color';
        let currentPatternColorName = 'Select a glaze color';
        let currentPattern = 'metaAndLines.svg';
        let clearGlazeMode = false;
        let currentBgSwatch = null;
        let currentPatternSwatch = null;
        let currentBgSwatchImage = null;
        let currentPatternSwatchImage = null;

        // Update swatch images in color info section
        function updateColorInfoSwatches() {
            const bgSwatchElement = document.getElementById('bgColorSwatch');
            const patternSwatchElement = document.getElementById('patternColorSwatch');
            
            if (bgSwatchElement && currentBgSwatchImage) {
                bgSwatchElement.style.backgroundImage = `url(${currentBgSwatchImage})`;
            } else if (bgSwatchElement) {
                bgSwatchElement.style.backgroundImage = 'none';
                bgSwatchElement.style.backgroundColor = currentBgColor;
            }
            
            if (patternSwatchElement && currentPatternSwatchImage) {
                patternSwatchElement.style.backgroundImage = `url(${currentPatternSwatchImage})`;
            } else if (patternSwatchElement) {
                patternSwatchElement.style.backgroundImage = 'none';
                patternSwatchElement.style.backgroundColor = currentPatternColor;
            }
        }

        // Update active states of swatches
        function updateSwatchActiveStates() {
            // Remove active class from all swatches
            document.querySelectorAll('.preset-color').forEach(swatch => {
                swatch.classList.remove('active');
            });
            
            // Add active class to currently selected swatches
            if (currentBgSwatch) {
                currentBgSwatch.classList.add('active');
            }
            if (currentPatternSwatch) {
                currentPatternSwatch.classList.add('active');
            }
        }

        // Create thumbnail for pattern
        function createThumbnail(patternFile, containerId) {
            const container = document.getElementById(containerId);
            const object = document.createElement('object');
            object.data = `patterns/${patternFile}`;
            object.type = 'image/svg+xml';
            object.style.width = '100%';
            object.style.height = '100%';
            
            object.addEventListener('load', function() {
                const svgDoc = object.contentDocument;
                if (svgDoc) {
                    const svg = svgDoc.querySelector('svg');
                    if (svg) {
                        svg.style.width = '100%';
                        svg.style.height = '100%';
                        svg.style.backgroundColor = '#000000';
                        
                        // Find and modify the path element for thumbnails
                        let path = null;
                        if (patternFile === 'metaAndLines.svg') {
                            path = svgDoc.querySelector('#path1514');
                        } else if (patternFile === 'metaOriginal.svg') {
                            path = svgDoc.querySelector('path');
                        } else if (patternFile === 'truchet.svg') {
                            path = svgDoc.querySelector('path');
                        } else if (patternFile === 'loopyLines.svg') {
                            path = svgDoc.querySelector('path');
                        }
                        
                        if (path) {
                            path.style.fill = '#ffffff';
                        }
                    }
                }
            });
            
            container.appendChild(object);
        }
        
        // Switch pattern
        function switchPattern(patternFile) {
            currentPattern = patternFile;
            const svgObject = document.getElementById('svgObject');
            svgObject.data = `patterns/${patternFile}`;
            
            // Update active thumbnail
            document.querySelectorAll('.pattern-thumb').forEach(thumb => {
                thumb.classList.remove('active');
            });
            document.querySelector(`[data-pattern="${patternFile}"]`).classList.add('active');
            
            // Update colors after pattern loads
            setTimeout(() => {
                updateColors();
            }, 100);
        }
        
        // Set up pattern selector
        function setupPatternSelector() {
            // Create thumbnails
            createThumbnail('metaAndLines.svg', 'metaAndLinesThumb');
            createThumbnail('metaOriginal.svg', 'metaOriginalThumb');
            createThumbnail('truchet.svg', 'truchetThumb');
            createThumbnail('loopyLines.svg', 'loopyLinesThumb');
            
            // Add click handlers
            document.querySelectorAll('.pattern-thumb').forEach(thumb => {
                thumb.addEventListener('click', function() {
                    const patternFile = this.getAttribute('data-pattern');
                    switchPattern(patternFile);
                });
            });
            
            // Set initial active pattern
            document.querySelector('[data-pattern="metaAndLines.svg"]').classList.add('active');
        }
        
        // Load colors from JSON file
        async function loadColors() {
            try {
                const response = await fetch('colors.json');
                colorsData = await response.json();
                
                // Extract underglaze left colors for background
                underglazeColors = colorsData.underglazes.map(ug => ({
                    id: ug.id,
                    name: ug.name,
                    color: ug.left,
                    image: ug.image
                }));
                
                // Extract glaze colors for pattern
                glazeColors = colorsData.glazes.map(g => ({
                    id: g.id,
                    name: g.name,
                    color: g.color,
                    image: g.image
                }));
                
                console.log('Loaded colors:', { underglazeColors: underglazeColors.length, glazeColors: glazeColors.length });
            } catch (error) {
                console.error('Error loading colors:', error);
                // Fallback to default colors
                underglazeColors = [{ id: 'default', name: 'White', color: '#ffffff' }];
                glazeColors = [{ id: 'default', name: 'Black', color: '#000000' }];
            }
        }

        // Initialize the color picker
        async function initColorPicker() {
            await loadColors();
            
            // Set up pattern selector
            setupPatternSelector();
            
            const presetContainer = document.getElementById('presetColors');

            // Create underglaze color buttons for background
            const underglazeSection = document.createElement('div');
            underglazeSection.className = 'color-section';
            underglazeSection.innerHTML = '<h4 style="margin-bottom: 10px; color: #495057; font-size: 0.9rem;">Underglaze Colors (Background):</h4>';
            
            const underglazeGrid = document.createElement('div');
            underglazeGrid.className = 'preset-colors';
            
            underglazeColors.forEach(ug => {
                const colorBtn = document.createElement('div');
                colorBtn.className = 'preset-color';
                colorBtn.style.backgroundImage = `url(${ug.image})`;
                colorBtn.title = `${ug.name} (${ug.id})`;
                colorBtn.onclick = () => {
                    currentBgColor = ug.color;
                    currentBgColorName = `${ug.name} (${ug.id})`;
                    currentBgSwatch = colorBtn;
                    currentBgSwatchImage = ug.image;
                    
                    // If clear glaze mode is on, also set pattern color to the "top" color
                    if (clearGlazeMode && colorsData && colorsData.underglazes) {
                        const underglazeData = colorsData.underglazes.find(u => u.left === ug.color);
                        if (underglazeData && underglazeData.top) {
                            currentPatternColor = underglazeData.top;
                            currentPatternColorName = 'Clear glaze';
                        }
                    }
                    
                    updateSwatchActiveStates();
                    updateColorInfoSwatches();
                    updateColors();
                };
                underglazeGrid.appendChild(colorBtn);
            });
            
            underglazeSection.appendChild(underglazeGrid);
            
            // Create glaze color buttons for pattern
            const glazeSection = document.createElement('div');
            glazeSection.className = 'color-section';
            glazeSection.innerHTML = '<h4 style="margin-bottom: 10px; color: #495057; font-size: 0.9rem;">Glaze Colors (Pattern):</h4>';
            
            const glazeGrid = document.createElement('div');
            glazeGrid.className = 'preset-colors';
            
            glazeColors.forEach(g => {
                const colorBtn = document.createElement('div');
                colorBtn.className = 'preset-color';
                colorBtn.style.backgroundImage = `url(${g.image})`;
                colorBtn.title = `${g.name} (${g.id})`;
                colorBtn.onclick = () => {
                    // Turn off clear glaze mode when selecting a glaze color
                    if (clearGlazeMode) {
                        clearGlazeMode = false;
                        const button = document.querySelector('.clear-glaze-btn');
                        button.classList.remove('active');
                        button.textContent = 'Clear Glaze';
                    }
                    
                    currentPatternColor = g.color;
                    currentPatternColorName = `${g.name} (${g.id})`;
                    currentPatternSwatch = colorBtn;
                    currentPatternSwatchImage = g.image;
                    updateSwatchActiveStates();
                    updateColorInfoSwatches();
                    updateColors();
                };
                glazeGrid.appendChild(colorBtn);
            });
            
            glazeSection.appendChild(glazeGrid);
            
            // Create underglaze color buttons for pattern (duplicate from left side)
            const underglazePatternSection = document.createElement('div');
            underglazePatternSection.className = 'color-section';
            underglazePatternSection.innerHTML = '<h4 style="margin-bottom: 10px; color: #495057; font-size: 0.9rem;">Underglaze Colors (Pattern):</h4>';
            
            const underglazePatternGrid = document.createElement('div');
            underglazePatternGrid.className = 'preset-colors';
            
            underglazeColors.forEach(ug => {
                const colorBtn = document.createElement('div');
                colorBtn.className = 'preset-color';
                colorBtn.style.backgroundImage = `url(${ug.image})`;
                colorBtn.title = `${ug.name} (${ug.id})`;
                colorBtn.onclick = () => {
                    // Turn off clear glaze mode when selecting an underglaze pattern color
                    if (clearGlazeMode) {
                        clearGlazeMode = false;
                        const button = document.querySelector('.clear-glaze-btn');
                        button.classList.remove('active');
                        button.textContent = 'Clear Glaze';
                    }
                    
                    currentPatternColor = ug.color;
                    currentPatternColorName = `${ug.name} (${ug.id})`;
                    currentPatternSwatch = colorBtn;
                    currentPatternSwatchImage = ug.image;
                    updateSwatchActiveStates();
                    updateColorInfoSwatches();
                    updateColors();
                };
                underglazePatternGrid.appendChild(colorBtn);
            });
            
            underglazePatternSection.appendChild(underglazePatternGrid);
            
            presetContainer.appendChild(underglazeSection);
            
            // Create a container for the pattern color sections
            const patternColorContainer = document.createElement('div');
            patternColorContainer.className = 'pattern-color-container';
            
            // Add Clear Glaze button above the right column
            const clearGlazeBtn = document.createElement('button');
            clearGlazeBtn.className = 'clear-glaze-btn';
            clearGlazeBtn.textContent = 'Clear Glaze';
            clearGlazeBtn.onclick = clearGlaze;
            patternColorContainer.appendChild(clearGlazeBtn);
            
            patternColorContainer.appendChild(glazeSection);
            patternColorContainer.appendChild(underglazePatternSection);
            
            presetContainer.appendChild(patternColorContainer);

            // Set default colors from the first items
            if (underglazeColors.length > 0) {
                currentBgColor = underglazeColors[0].color;
                currentBgColorName = `${underglazeColors[0].name} (${underglazeColors[0].id})`;
            }
            if (glazeColors.length > 0) {
                currentPatternColor = glazeColors[0].color;
                currentPatternColorName = `${glazeColors[0].name} (${glazeColors[0].id})`;
            }

            // Set initial swatch references
            const underglazeSwatches = document.querySelectorAll('.color-section')[0]?.querySelectorAll('.preset-color');
            currentBgSwatch = underglazeSwatches && underglazeSwatches.length > 0 ? underglazeSwatches[0] : null;
            currentBgSwatchImage = underglazeColors.length > 0 ? underglazeColors[0].image : null;
            
            const glazeSwatches = document.querySelectorAll('.color-section')[1]?.querySelectorAll('.preset-color');
            currentPatternSwatch = glazeSwatches && glazeSwatches.length > 0 ? glazeSwatches[0] : null;
            currentPatternSwatchImage = glazeColors.length > 0 ? glazeColors[0].image : null;

            // Initial update
            updateSwatchActiveStates();
            updateColorInfoSwatches();
            updateColors();
        }

        // Update SVG colors
        function updateColors() {
            const svgObject = document.getElementById('svgObject');
            const bgColor = currentBgColor;
            const patternColor = currentPatternColor;
            
            // Update color name displays
            document.getElementById('bgColorName').textContent = currentBgColorName;
            document.getElementById('patternColorName').textContent = currentPatternColorName;

            // Wait for SVG to load
            svgObject.addEventListener('load', function() {
                const svgDoc = svgObject.contentDocument;
                if (svgDoc) {
                    // Update background
                    const svgElement = svgDoc.querySelector('svg');
                    if (svgElement) {
                        svgElement.style.backgroundColor = bgColor;
                    }

                    // Update pattern color for the main element
                    const path = svgDoc.querySelector('#main');
                    
                    if (path) {
                        // Set both fill attribute and style fill for compatibility
                        path.setAttribute('fill', patternColor);
                        path.style.fill = patternColor;
                    }
                }
            });

            // If already loaded, update immediately
            if (svgObject.contentDocument) {
                const svgDoc = svgObject.contentDocument;
                const svgElement = svgDoc.querySelector('svg');
                
                if (svgElement) {
                    svgElement.style.backgroundColor = bgColor;
                }
                
                // Update pattern color for the main element
                const path = svgDoc.querySelector('#main');
                
                if (path) {
                    // Set both fill attribute and style fill for compatibility
                    path.setAttribute('fill', patternColor);
                    path.style.fill = patternColor;
                }
            }
        }

        // Clear glaze toggle - toggle between normal and clear glaze mode
        function clearGlaze() {
            clearGlazeMode = !clearGlazeMode;
            const button = document.querySelector('.clear-glaze-btn');
            
            if (clearGlazeMode) {
                button.classList.add('active');
                button.textContent = 'Clear Glaze (ON)';
                // Apply clear glaze mode to current selection
                applyClearGlazeMode();
            } else {
                button.classList.remove('active');
                button.textContent = 'Clear Glaze';
                // Reset to normal mode - use first glaze color
                if (glazeColors.length > 0) {
                    currentPatternColor = glazeColors[0].color;
                    currentPatternColorName = `${glazeColors[0].name} (${glazeColors[0].id})`;
                    updateColors();
                }
            }
        }

        // Apply clear glaze mode - set pattern color to "top" color of current underglaze
        function applyClearGlazeMode() {
            if (colorsData && colorsData.underglazes) {
                // Find the currently selected underglaze by matching the current background color
                const currentUnderglaze = colorsData.underglazes.find(ug => ug.left === currentBgColor);
                
                if (currentUnderglaze && currentUnderglaze.top) {
                    currentPatternColor = currentUnderglaze.top;
                    currentPatternColorName = 'Clear glaze';
                    
                    // Clear pattern swatch reference since we're in clear glaze mode
                    currentPatternSwatch = null;
                    currentPatternSwatchImage = null;
                    updateSwatchActiveStates();
                    updateColorInfoSwatches();
                    updateColors();
                } else {
                    console.warn('Could not find matching underglaze for current background color');
                }
            }
        }


        // Download SVG
        function downloadSVG() {
            const svgObject = document.getElementById('svgObject');
            const bgColor = currentBgColor;
            const patternColor = currentPatternColor;

            svgObject.addEventListener('load', function() {
                const svgDoc = svgObject.contentDocument;
                if (svgDoc) {
                    const svgElement = svgDoc.querySelector('svg');
                    
                    // Find the main element
                    const path = svgDoc.querySelector('#main');
                    
                    if (svgElement && path) {
                        // Create a copy of the SVG
                        const svgClone = svgElement.cloneNode(true);
                        
                        // Find the corresponding main element in the clone
                        const pathClone = svgClone.querySelector('#main');
                        
                        // Apply colors
                        svgClone.style.backgroundColor = bgColor;
                        if (pathClone) {
                            // Set both fill attribute and style fill for compatibility
                            pathClone.setAttribute('fill', patternColor);
                            pathClone.style.fill = patternColor;
                        }
                        
                        
                        // Convert to string
                        const svgString = new XMLSerializer().serializeToString(svgClone);
                        const blob = new Blob([svgString], { type: 'image/svg+xml' });
                        const url = URL.createObjectURL(blob);
                        
                        // Create download link with descriptive filename
                        const a = document.createElement('a');
                        a.href = url;
                        const patternName = currentPattern.replace('.svg', '');
                        const filename = `${currentBgColorName.replace(/[^a-zA-Z0-9]/g, '_')}_${currentPatternColorName.replace(/[^a-zA-Z0-9]/g, '_')}_${patternName}.svg`;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }
                }
            });

            // If already loaded, download immediately
            if (svgObject.contentDocument) {
                const svgDoc = svgObject.contentDocument;
                const svgElement = svgDoc.querySelector('svg');
                
                // Find the main element (consistent with event listener)
                const path = svgDoc.querySelector('#main');
                
                if (svgElement && path) {
                    const svgClone = svgElement.cloneNode(true);
                    
                    // Find the corresponding main element in the clone
                    const pathClone = svgClone.querySelector('#main');
                    
                    // Apply colors
                    svgClone.style.backgroundColor = bgColor;
                    if (pathClone) {
                        // Set both fill attribute and style fill for compatibility
                        pathClone.setAttribute('fill', patternColor);
                        pathClone.style.fill = patternColor;
                    }
                    
                    const svgString = new XMLSerializer().serializeToString(svgClone);
                    const blob = new Blob([svgString], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    const patternName = currentPattern.replace('.svg', '');
                    const filename = `${currentBgColorName.replace(/[^a-zA-Z0-9]/g, '_')}_${currentPatternColorName.replace(/[^a-zA-Z0-9]/g, '_')}_${patternName}.svg`;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }
        }

        // Slack bot configuration
        const slackMentionUser = '@thisisjohnbrown';
        const API_BASE_URL = window.location.origin; // Use same origin for API calls

        // Send to Slack function using the new bot API
        async function sendToSlack() {
            // Show loading state
            const slackBtn = document.querySelector('.slack-btn');
            const originalText = slackBtn.textContent;
            slackBtn.textContent = 'Sending...';
            slackBtn.disabled = true;

            try {
                console.log('ðŸš€ Starting Slack bot send process...');
                
                // Extract SVG using EXACT same logic as downloadSVG
                const svgObject = document.getElementById('svgObject');
                const bgColor = currentBgColor;
                const patternColor = currentPatternColor;
                
                const svgString = await new Promise((resolve, reject) => {
                    svgObject.addEventListener('load', function() {
                        const svgDoc = svgObject.contentDocument;
                        if (svgDoc) {
                            const svgElement = svgDoc.querySelector('svg');
                            
                            // Find the main element
                            const path = svgDoc.querySelector('#main');
                            
                            if (svgElement && path) {
                                // Create a copy of the SVG
                                const svgClone = svgElement.cloneNode(true);
                                
                                // Find the corresponding main element in the clone
                                const pathClone = svgClone.querySelector('#main');
                                
                                // Apply colors
                                svgClone.style.backgroundColor = bgColor;
                                if (pathClone) {
                                    // Set both fill attribute and style fill for compatibility
                                    pathClone.setAttribute('fill', patternColor);
                                    pathClone.style.fill = patternColor;
                                }
                                
                                // Convert to string
                                const svgString = new XMLSerializer().serializeToString(svgClone);
                                resolve(svgString);
                            } else {
                                reject(new Error('Could not find SVG element or path'));
                            }
                        } else {
                            reject(new Error('Could not access SVG document'));
                        }
                    });
                    
                    // If already loaded, trigger immediately
                    if (svgObject.contentDocument) {
                        svgObject.dispatchEvent(new Event('load'));
                    }
                });
                
                console.log('ðŸ“ Extracted SVG from webpage, length:', svgString.length);
                
                // Prepare the data for the API
                const requestData = {
                    svgContent: svgString,
                    pattern: currentPattern,
                    bgColor: currentBgColor,
                    patternColor: currentPatternColor,
                    bgColorName: currentBgColorName,
                    patternColorName: currentPatternColorName,
                    channel: '#color-requests' // Default channel
                };

                console.log('ðŸ“ Sending SVG data to bot API');
                
                // Send to our bot API
                const response = await fetch(`${API_BASE_URL}/api/send-to-slack`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    console.log('âœ… Pattern sent successfully via bot:', result);
                    // Success - no alert needed
                } else {
                    console.error('âŒ Bot API error:', result);
                    throw new Error(result.error || 'Failed to send to Slack');
                }

            } catch (error) {
                console.error('ðŸ’¥ Error sending to Slack via bot:', error);
                alert('Error sending to Slack: ' + error.message);
            } finally {
                // Reset button state
                slackBtn.textContent = originalText;
                slackBtn.disabled = false;
            }
        }

        // Parse URL parameters
        function getUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            return {
                pattern: urlParams.get('pattern'),
                bgColor: urlParams.get('bgColor'),
                patternColor: urlParams.get('patternColor'),
                bgColorName: urlParams.get('bgColorName'),
                patternColorName: urlParams.get('patternColorName')
            };
        }

        // Apply URL parameters to the color picker
        function applyUrlParams() {
            const params = getUrlParams();
            
            if (params.pattern) {
                console.log('ðŸŽ¯ Loading pattern from URL:', params.pattern);
                switchPattern(params.pattern);
            }
            
            if (params.bgColor && params.bgColorName) {
                console.log('ðŸŽ¨ Loading background color from URL:', params.bgColorName, params.bgColor);
                currentBgColor = params.bgColor;
                currentBgColorName = decodeURIComponent(params.bgColorName);
                
                // Find and select the matching underglaze swatch
                const underglazeSwatches = document.querySelectorAll('.color-section')[0]?.querySelectorAll('.preset-color');
                if (underglazeSwatches) {
                    underglazeSwatches.forEach(swatch => {
                        const swatchTitle = swatch.title || '';
                        const decodedBgColorName = decodeURIComponent(params.bgColorName);
                        
                        // Check if this swatch matches the background color name
                        if (swatchTitle.includes(decodedBgColorName) || swatchTitle.includes(params.bgColorName)) {
                            currentBgSwatch = swatch;
                            currentBgSwatchImage = swatch.style.backgroundImage.replace(/url\(['"]?(.*?)['"]?\)/, '$1');
                            console.log('âœ… Found matching background swatch:', swatchTitle);
                        }
                    });
                }
            }
            
            if (params.patternColor && params.patternColorName) {
                console.log('ðŸŽ¨ Loading pattern color from URL:', params.patternColorName, params.patternColor);
                currentPatternColor = params.patternColor;
                currentPatternColorName = decodeURIComponent(params.patternColorName);
                
                // Find and select the matching pattern color swatch
                const patternColorSections = document.querySelectorAll('.color-section');
                for (let i = 1; i < patternColorSections.length; i++) {
                    const swatches = patternColorSections[i].querySelectorAll('.preset-color');
                    swatches.forEach(swatch => {
                        const swatchTitle = swatch.title || '';
                        const decodedPatternColorName = decodeURIComponent(params.patternColorName);
                        
                        // Check if this swatch matches the pattern color name
                        if (swatchTitle.includes(decodedPatternColorName) || swatchTitle.includes(params.patternColorName)) {
                            currentPatternSwatch = swatch;
                            currentPatternSwatchImage = swatch.style.backgroundImage.replace(/url\(['"]?(.*?)['"]?\)/, '$1');
                            console.log('âœ… Found matching pattern swatch:', swatchTitle);
                        }
                    });
                }
            }
            
            // Update the display with a slight delay to ensure DOM is ready
            setTimeout(() => {
                updateSwatchActiveStates();
                updateColorInfoSwatches();
                updateColors();
                console.log('ðŸŽ¨ Applied URL parameters - current state:', {
                    pattern: currentPattern,
                    bgColor: currentBgColor,
                    bgColorName: currentBgColorName,
                    patternColor: currentPatternColor,
                    patternColorName: currentPatternColorName
                });
            }, 100);
        }

        // Generate shareable URL
        function generateShareUrl() {
            const baseUrl = window.location.origin + window.location.pathname;
            const params = new URLSearchParams();
            
            params.set('pattern', currentPattern);
            params.set('bgColor', currentBgColor);
            params.set('patternColor', currentPatternColor);
            params.set('bgColorName', encodeURIComponent(currentBgColorName));
            params.set('patternColorName', encodeURIComponent(currentPatternColorName));
            
            return `${baseUrl}?${params.toString()}`;
        }


        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initColorPicker();
            
            // Apply URL parameters after a short delay to ensure everything is loaded
            setTimeout(() => {
                applyUrlParams();
            }, 500);
        });
    </script>
</body>
</html>
